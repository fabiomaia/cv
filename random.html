<link rel="stylesheet" href="styles/sakura.css" media="screen">

<h1>Random</h1>
<p>Random snippets, random thoughts, random things.</p>

<h2>Organization</h2>

- Paper notebook

<h2>Open all files in a directory in vim splits</h2>

<pre>vim -o $(ls -1)</pre>
<pre>vim -o *</pre>

<h2>Run local script on remote host</h2>

<pre>
ssh foo < bar.sh
</pre>

<h2>Simple parallelization of tasks</h2>
If you want to parallelize commands `foo`, `bar`, and `baz`, but you need to block until they all complete, you can:

<pre>
foo &
bar &
baz &
wait
</pre>

<h2>POSIX shell key-value store backed by the filesystem</h2>
POSIX shells lack syntax for dictionary data structures, so if you need something that works everywhere you can leverage the filesystem to read and write stuff with surprisingly decent syntax

<pre>
db=$(mktemp -d)
trap "rm -rf $db/" EXIT INT HUP TERM

# Writing
echo "1" > $db/foo
echo "2" > $db/bar

# Reading
foo=$(cat $db/foo)
bar=$(cat $db/bar)
</pre>

If you are familiar with POSIX shell scripting this should feel like home to you.

<h2>One-line basic HTTP GET</h2>
If you need to issue a very simple HTTP GET request from a constrained environment where you won't find <code>curl</code>, you can write
<pre>
printf 'GET / HTTP/1.1\r\nHost: example.com\r\n\r\n' | nc example.com 80
</pre>

<h2>Find which well-known service a port is servicing</h2>
<pre>
cat /etc/services | grep "3306/tcp"
mysql		3306/tcp
</pre>

<h2>The only shell command that returns itself</h2>
<pre>
cat /proc/self/cmdline
</pre>

<h2>Container suicide</h2>
At the end of the day, a container is just a process running on a host machine with some pid P. However from the perspective of the container this process is the root process with pid 1, either some init process (LXD) or an application (Docker). Thus killing process with pid 1 will kill the container on the host.
<pre>
kill 1
</pre>

<h2>Enable fast internet</h2>

<pre>
apt install speedtest
(while true; do speedtest; sleep 120; done) &
</pre>

<h2>git bisect</h2>

<p>I just learned that with git bisect you can give git (1) a bad commit/branch, (2) a known good previous commit/branch, (3) a command to test said “goodness” (e.g. passing unit tests, passing linting, etc) and git will do a binary search between those commits, narrowing down the window at every step trying to find the commit that introduced the problem.</p>

<p>Say you are implementing a new feature in branch <code>feature/someNewFeatureWip</code> and you realize after some 7 commits in this branch that you introduced a bug. If you have tests that catch that bug you can find the culprit commit quite easily:</p>

<pre>
$ git bisect start
$ git bisect bad feature/someNewFeatureWip                          # (1)
$ git bisect good develop                                           # (2) 
$ git bisect run sh -c 'flutter build && flutter test && ...'       # (3)
</pre>

<p>Of course, for best results you need good modular commits and good extensive testing.</p>

<p>Otherwise you can still use git bisect to manually mark commits as good and bad (to help you do the binary search in your head) and test manually rather than automatically, which is all you can do in some cases when the testing isn't there.</p>
